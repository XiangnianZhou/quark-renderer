<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">var env = require(&quot;../core/env&quot;);

var _vector = require(&quot;../core/utils/vector&quot;);

var applyTransform = _vector.applyTransform;

var BoundingRect = require(&quot;../core/BoundingRect&quot;);

var colorTool = require(&quot;../core/utils/colorUtil&quot;);

var textContain = require(&quot;../core/contain/text&quot;);

var textUtil = require(&quot;../graphic/utils/textUtil&quot;);

var RectText = require(&quot;../graphic/RectText&quot;);

var Displayable = require(&quot;../graphic/Displayable&quot;);

var QImage = require(&quot;../graphic/Image&quot;);

var Text = require(&quot;../graphic/Text&quot;);

var Path = require(&quot;../graphic/Path&quot;);

var PathProxy = require(&quot;../graphic/PathProxy&quot;);

var Gradient = require(&quot;../graphic/gradient/Gradient&quot;);

var vmlCore = require(&quot;./core&quot;);

function _typeof(obj) { &quot;@babel/helpers - typeof&quot;; if (typeof Symbol === &quot;function&quot; &amp;&amp; typeof Symbol.iterator === &quot;symbol&quot;) { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj &amp;&amp; typeof Symbol === &quot;function&quot; &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? &quot;symbol&quot; : typeof obj; }; } return _typeof(obj); }

// http://www.w3.org/TR/NOTE-VML
// TODO:Use proxy like svg instead of overwrite brush methods
var CMD = PathProxy.CMD;
var round = Math.round;
var sqrt = Math.sqrt;
var abs = Math.abs;
var cos = Math.cos;
var sin = Math.sin;
var mathMax = Math.max;

if (!env.canvasSupported) {
  var comma = &#39;,&#39;;
  var imageTransformPrefix = &#39;progid:DXImageTransform.Microsoft&#39;;
  var Z = 21600;
  var Z2 = Z / 2;
  var ZLEVEL_BASE = 100000;
  var Z_BASE = 1000;

  var initRootElStyle = function initRootElStyle(el) {
    el.style.cssText = &#39;position:absolute;left:0;top:0;width:1px;height:1px;&#39;;
    el.coordsize = Z + &#39;,&#39; + Z;
    el.coordorigin = &#39;0,0&#39;;
  };

  var encodeHtmlAttribute = function encodeHtmlAttribute(s) {
    return String(s).replace(/&amp;/g, &#39;&amp;amp;&#39;).replace(/&quot;/g, &#39;&amp;quot;&#39;);
  };

  var rgb2Str = function rgb2Str(r, g, b) {
    return &#39;rgb(&#39; + [r, g, b].join(&#39;,&#39;) + &#39;)&#39;;
  };

  var append = function append(parent, child) {
    if (child &amp;&amp; parent &amp;&amp; child.parentNode !== parent) {
      parent.appendChild(child);
    }
  };

  var remove = function remove(parent, child) {
    if (child &amp;&amp; parent &amp;&amp; child.parentNode === parent) {
      parent.removeChild(child);
    }
  };

  var getZIndex = function getZIndex(zlevel, z, z2) {
    // z 的取值范围为 [0, 1000]
    return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;
  };

  var parsePercent = textUtil.parsePercent; //--------------PATH----------------------

  var setColorAndOpacity = function setColorAndOpacity(el, color, opacity) {
    var colorArr = colorTool.parse(color);
    opacity = +opacity;

    if (isNaN(opacity)) {
      opacity = 1;
    }

    if (colorArr) {
      el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);
      el.opacity = opacity * colorArr[3];
    }
  };

  var getColorAndAlpha = function getColorAndAlpha(color) {
    var colorArr = colorTool.parse(color);
    return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];
  };

  var updateFillNode = function updateFillNode(el, style, qrEl) {
    // TODO pattern
    var fill = style.fill;

    if (fill != null) {
      // Modified from excanvas
      if (fill instanceof Gradient) {
        var gradientType;
        var angle = 0;
        var focus = [0, 0]; // additional offset

        var shift = 0; // scale factor for offset

        var expansion = 1;
        var rect = qrEl.getBoundingRect();
        var rectWidth = rect.width;
        var rectHeight = rect.height;

        if (fill.type === &#39;linear&#39;) {
          gradientType = &#39;gradient&#39;;
          var transform = qrEl.transform;
          var p0 = [fill.x * rectWidth, fill.y * rectHeight];
          var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];

          if (transform) {
            applyTransform(p0, p0, transform);
            applyTransform(p1, p1, transform);
          }

          var dx = p1[0] - p0[0];
          var dy = p1[1] - p0[1];
          angle = Math.atan2(dx, dy) * 180 / Math.PI; // The angle should be a non-negative number.

          if (angle &lt; 0) {
            angle += 360;
          } // Very small angles produce an unexpected result because they are
          // converted to a scientific notation string.


          if (angle &lt; 1e-6) {
            angle = 0;
          }
        } else {
          gradientType = &#39;gradientradial&#39;;
          var _p = [fill.x * rectWidth, fill.y * rectHeight];
          var _transform = qrEl.transform;
          var scale = qrEl.scale;
          var width = rectWidth;
          var height = rectHeight;
          focus = [// Percent in bounding rect
          (_p[0] - rect.x) / width, (_p[1] - rect.y) / height];

          if (_transform) {
            applyTransform(_p, _p, _transform);
          }

          width /= scale[0] * Z;
          height /= scale[1] * Z;
          var dimension = mathMax(width, height);
          shift = 2 * 0 / dimension;
          expansion = 2 * fill.r / dimension - shift;
        } // We need to sort the color stops in ascending order by offset,
        // otherwise IE won&#39;t interpret it correctly.


        var stops = fill.colorStops.slice();
        stops.sort(function (cs1, cs2) {
          return cs1.offset - cs2.offset;
        });
        var length = stops.length; // Color and alpha list of first and last stop

        var colorAndAlphaList = [];
        var colors = [];

        for (var i = 0; i &lt; length; i++) {
          var stop = stops[i];
          var colorAndAlpha = getColorAndAlpha(stop.color);
          colors.push(stop.offset * expansion + shift + &#39; &#39; + colorAndAlpha[0]);

          if (i === 0 || i === length - 1) {
            colorAndAlphaList.push(colorAndAlpha);
          }
        }

        if (length &gt;= 2) {
          var color1 = colorAndAlphaList[0][0];
          var color2 = colorAndAlphaList[1][0];
          var opacity1 = colorAndAlphaList[0][1] * style.opacity;
          var opacity2 = colorAndAlphaList[1][1] * style.opacity;
          el.type = gradientType;
          el.method = &#39;none&#39;;
          el.focus = &#39;100%&#39;;
          el.angle = angle;
          el.color = color1;
          el.color2 = color2;
          el.colors = colors.join(&#39;,&#39;); // When colors attribute is used, the meanings of opacity and o:opacity2
          // are reversed.

          el.opacity = opacity2; // FIXME g_o_:opacity ?

          el.opacity2 = opacity1;
        }

        if (gradientType === &#39;radial&#39;) {
          el.focusposition = focus.join(&#39;,&#39;);
        }
      } else {
        // FIXME Change from Gradient fill to color fill
        setColorAndOpacity(el, fill, style.opacity);
      }
    }
  };

  var updateStrokeNode = function updateStrokeNode(el, style) {
    // if (style.lineJoin != null) {
    //     el.joinstyle = style.lineJoin;
    // }
    // if (style.miterLimit != null) {
    //     el.miterlimit = style.miterLimit * Z;
    // }
    // if (style.lineCap != null) {
    //     el.endcap = style.lineCap;
    // }
    if (style.lineDash) {
      el.dashstyle = style.lineDash.join(&#39; &#39;);
    }

    if (style.stroke != null &amp;&amp; !(style.stroke instanceof Gradient)) {
      setColorAndOpacity(el, style.stroke, style.opacity);
    }
  };

  var updateFillAndStroke = function updateFillAndStroke(vmlEl, type, style, qrEl) {
    var isFill = type === &#39;fill&#39;;
    var el = vmlEl.getElementsByTagName(type)[0]; // Stroke must have lineWidth

    if (style[type] != null &amp;&amp; style[type] !== &#39;none&#39; &amp;&amp; (isFill || !isFill &amp;&amp; style.lineWidth)) {
      vmlEl[isFill ? &#39;filled&#39; : &#39;stroked&#39;] = &#39;true&#39;; // FIXME Remove before updating, or set `colors` will throw error

      if (style[type] instanceof Gradient) {
        remove(vmlEl, el);
      }

      if (!el) {
        el = vmlCore.createNode(type);
      }

      isFill ? updateFillNode(el, style, qrEl) : updateStrokeNode(el, style);
      append(vmlEl, el);
    } else {
      vmlEl[isFill ? &#39;filled&#39; : &#39;stroked&#39;] = &#39;false&#39;;
      remove(vmlEl, el);
    }
  };

  var points = [[], [], []];

  var pathDataToString = function pathDataToString(path, m) {
    var M = CMD.M;
    var C = CMD.C;
    var L = CMD.L;
    var A = CMD.A;
    var Q = CMD.Q;
    var str = [];
    var nPoint;
    var cmdStr;
    var cmd;
    var i;
    var xi;
    var yi;
    var data = path.data;
    var dataLength = path.len();
    var x;
    var y;
    var x0;
    var y0;
    var x1;
    var y1;
    var x2;
    var y2;
    var x3;
    var y3;
    var cx;
    var cy;
    var sx;
    var sy;
    var rx;
    var ry;

    for (i = 0; i &lt; dataLength;) {
      cmd = data[i++];
      cmdStr = &#39;&#39;;
      nPoint = 0;

      switch (cmd) {
        case M:
          cmdStr = &#39; m &#39;;
          nPoint = 1;
          xi = data[i++];
          yi = data[i++];
          points[0][0] = xi;
          points[0][1] = yi;
          break;

        case L:
          cmdStr = &#39; l &#39;;
          nPoint = 1;
          xi = data[i++];
          yi = data[i++];
          points[0][0] = xi;
          points[0][1] = yi;
          break;

        case Q:
        case C:
          cmdStr = &#39; c &#39;;
          nPoint = 3;
          x1 = data[i++];
          y1 = data[i++];
          x2 = data[i++];
          y2 = data[i++];

          if (cmd === Q) {
            // Convert quadratic to cubic using degree elevation
            x3 = x2;
            y3 = y2;
            x2 = (x2 + 2 * x1) / 3;
            y2 = (y2 + 2 * y1) / 3;
            x1 = (xi + 2 * x1) / 3;
            y1 = (yi + 2 * y1) / 3;
          } else {
            x3 = data[i++];
            y3 = data[i++];
          }

          points[0][0] = x1;
          points[0][1] = y1;
          points[1][0] = x2;
          points[1][1] = y2;
          points[2][0] = x3;
          points[2][1] = y3;
          xi = x3;
          yi = y3;
          break;

        case A:
          x = 0;
          y = 0;
          sx = 1;
          sy = 1;
          var angle = 0;

          if (m) {
            // Extract SRT from matrix
            x = m[4];
            y = m[5];
            sx = sqrt(m[0] * m[0] + m[1] * m[1]);
            sy = sqrt(m[2] * m[2] + m[3] * m[3]);
            angle = Math.atan2(-m[1] / sy, m[0] / sx);
          }

          cx = data[i++];
          cy = data[i++];
          rx = data[i++];
          ry = data[i++];
          var startAngle = data[i++] + angle;
          var endAngle = data[i++] + startAngle + angle; // FIXME
          // let psi = data[i++];

          i++;
          var clockwise = data[i++];
          x0 = cx + cos(startAngle) * rx;
          y0 = cy + sin(startAngle) * ry;
          x1 = cx + cos(endAngle) * rx;
          y1 = cy + sin(endAngle) * ry;
          var type = clockwise ? &#39; wa &#39; : &#39; at &#39;;

          if (Math.abs(x0 - x1) &lt; 1e-4) {
            // IE won&#39;t render arches drawn counter clockwise if x0 == x1.
            if (Math.abs(endAngle - startAngle) &gt; 1e-2) {
              // Offset x0 by 1/80 of a pixel. Use something
              // that can be represented in binary
              if (clockwise) {
                x0 += 270 / Z;
              }
            } else {
              // Avoid case draw full circle
              if (Math.abs(y0 - cy) &lt; 1e-4) {
                if (clockwise &amp;&amp; x0 &lt; cx || !clockwise &amp;&amp; x0 &gt; cx) {
                  y1 -= 270 / Z;
                } else {
                  y1 += 270 / Z;
                }
              } else if (clockwise &amp;&amp; y0 &lt; cy || !clockwise &amp;&amp; y0 &gt; cy) {
                x1 += 270 / Z;
              } else {
                x1 -= 270 / Z;
              }
            }
          }

          str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));
          xi = x1;
          yi = y1;
          break;

        case CMD.R:
          var p0 = points[0];
          var p1 = points[1]; // x0, y0

          p0[0] = data[i++];
          p0[1] = data[i++]; // x1, y1

          p1[0] = p0[0] + data[i++];
          p1[1] = p0[1] + data[i++];

          if (m) {
            applyTransform(p0, p0, m);
            applyTransform(p1, p1, m);
          }

          p0[0] = round(p0[0] * Z - Z2);
          p1[0] = round(p1[0] * Z - Z2);
          p0[1] = round(p0[1] * Z - Z2);
          p1[1] = round(p1[1] * Z - Z2);
          str.push( // x0, y0
          &#39; m &#39;, p0[0], comma, p0[1], // x1, y0
          &#39; l &#39;, p1[0], comma, p0[1], // x1, y1
          &#39; l &#39;, p1[0], comma, p1[1], // x0, y1
          &#39; l &#39;, p0[0], comma, p1[1]);
          break;

        case CMD.Z:
          // FIXME Update xi, yi
          str.push(&#39; x &#39;);
      }

      if (nPoint &gt; 0) {
        str.push(cmdStr);

        for (var k = 0; k &lt; nPoint; k++) {
          var p = points[k];
          m &amp;&amp; applyTransform(p, p, m); // 不 round 会非常慢

          str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k &lt; nPoint - 1 ? comma : &#39;&#39;);
        }
      }
    }

    return str.join(&#39;&#39;);
  };
<span id='qrenderer-vml-Path'>  /**
</span>   * @class qrenderer.vml.Path
   * 
   * Append brushVML method to standard shape classes inside graphic package, VMLPainter will
   * use this method instead of standard brush() method.
   * 
   * 在标准的 shape 类上扩展一个 brushVML 方法，在 VMLPainter 中会调用此方法，而不是标准的 brush 方法。
   * 
   * @docauthor 大漠穷秋 damoqiongqiu@126.com
   */
  // Rewrite the original path method


  Path.prototype.brushVML = function (vmlRoot) {
    var style = this.style;
    var vmlEl = this._vmlEl;

    if (!vmlEl) {
      vmlEl = vmlCore.createNode(&#39;shape&#39;);
      initRootElStyle(vmlEl);
      this._vmlEl = vmlEl;
    }

    updateFillAndStroke(vmlEl, &#39;fill&#39;, style, this);
    updateFillAndStroke(vmlEl, &#39;stroke&#39;, style, this);
    var m = this.transform;
    var needTransform = m != null;
    var strokeEl = vmlEl.getElementsByTagName(&#39;stroke&#39;)[0];

    if (strokeEl) {
      var lineWidth = style.lineWidth; // Get the line scale.
      // Determinant of this.m_ means how much the area is enlarged by the
      // transformation. So its square root can be used as a scale factor
      // for width.

      if (needTransform &amp;&amp; !style.strokeNoScale) {
        var det = m[0] * m[3] - m[1] * m[2];
        lineWidth *= sqrt(abs(det));
      }

      strokeEl.weight = lineWidth + &#39;px&#39;;
    }

    var path = this.path || (this.path = new PathProxy());

    if (this.__dirtyPath) {
      path.beginPath();
      path.subPixelOptimize = false;
      this.buildPath(path, this.shape);
      path.toStatic();
      this.__dirtyPath = false;
    }

    vmlEl.path = pathDataToString(path, this.transform);
    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root

    append(vmlRoot, vmlEl); // Text

    if (style.text != null) {
      this.drawRectText(vmlRoot, this.getBoundingRect());
    } else {
      this.removeRectText(vmlRoot);
    }
  };

  Path.prototype.onRemove = function (vmlRoot) {
    remove(vmlRoot, this._vmlEl);
    this.removeRectText(vmlRoot);
  };

  Path.prototype.onAdd = function (vmlRoot) {
    append(vmlRoot, this._vmlEl);
    this.appendRectText(vmlRoot);
  }; //--------------IMAGE----------------------


  var isImage = function isImage(img) {
    // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错
    return _typeof(img) === &#39;object&#39; &amp;&amp; img.tagName &amp;&amp; img.tagName.toUpperCase() === &#39;IMG&#39;; // return img instanceof Image;
  };
<span id='qrenderer-vml-QImage'>  /**
</span>   * @class qrenderer.vml.QImage
   * 
   * @docauthor 大漠穷秋 damoqiongqiu@126.com
   */
  // Rewrite the original path method


  QImage.prototype.brushVML = function (vmlRoot) {
    var style = this.style;
    var image = style.image; // Image original width, height

    var ow;
    var oh;

    if (isImage(image)) {
      var src = image.src;

      if (src === this._imageSrc) {
        ow = this._imageWidth;
        oh = this._imageHeight;
      } else {
        var imageRuntimeStyle = image.runtimeStyle;
        var oldRuntimeWidth = imageRuntimeStyle.width;
        var oldRuntimeHeight = imageRuntimeStyle.height;
        imageRuntimeStyle.width = &#39;auto&#39;;
        imageRuntimeStyle.height = &#39;auto&#39;; // get the original size

        ow = image.width;
        oh = image.height; // and remove overides

        imageRuntimeStyle.width = oldRuntimeWidth;
        imageRuntimeStyle.height = oldRuntimeHeight; // Caching image original width, height and src

        this._imageSrc = src;
        this._imageWidth = ow;
        this._imageHeight = oh;
      }

      image = src;
    } else {
      if (image === this._imageSrc) {
        ow = this._imageWidth;
        oh = this._imageHeight;
      }
    }

    if (!image) {
      return;
    }

    var x = style.x || 0;
    var y = style.y || 0;
    var dw = style.width;
    var dh = style.height;
    var sw = style.sWidth;
    var sh = style.sHeight;
    var sx = style.sx || 0;
    var sy = style.sy || 0;
    var hasCrop = sw &amp;&amp; sh;
    var vmlEl = this._vmlEl;

    if (!vmlEl) {
      // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。
      // vmlEl = vmlCore.createNode(&#39;group&#39;);
      vmlEl = vmlCore.doc.createElement(&#39;div&#39;);
      initRootElStyle(vmlEl);
      this._vmlEl = vmlEl;
    }

    var vmlElStyle = vmlEl.style;
    var hasRotation = false;
    var m;
    var scaleX = 1;
    var scaleY = 1;

    if (this.transform) {
      m = this.transform;
      scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);
      scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);
      hasRotation = m[1] || m[2];
    }

    if (hasRotation) {
      // If filters are necessary (rotation exists), create them
      // filters are bog-slow, so only create them if abbsolutely necessary
      // The following check doesn&#39;t account for skews (which don&#39;t exist
      // in the canvas spec (yet) anyway.
      // From excanvas
      var p0 = [x, y];
      var p1 = [x + dw, y];
      var p2 = [x, y + dh];
      var p3 = [x + dw, y + dh];
      applyTransform(p0, p0, m);
      applyTransform(p1, p1, m);
      applyTransform(p2, p2, m);
      applyTransform(p3, p3, m);
      var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);
      var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);
      var transformFilter = [];
      transformFilter.push(&#39;M11=&#39;, m[0] / scaleX, comma, &#39;M12=&#39;, m[2] / scaleY, comma, &#39;M21=&#39;, m[1] / scaleX, comma, &#39;M22=&#39;, m[3] / scaleY, comma, &#39;Dx=&#39;, round(x * scaleX + m[4]), comma, &#39;Dy=&#39;, round(y * scaleY + m[5]));
      vmlElStyle.padding = &#39;0 &#39; + round(maxX) + &#39;px &#39; + round(maxY) + &#39;px 0&#39;; // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用

      vmlElStyle.filter = imageTransformPrefix + &#39;.Matrix(&#39; + transformFilter.join(&#39;&#39;) + &#39;, SizingMethod=clip)&#39;;
    } else {
      if (m) {
        x = x * scaleX + m[4];
        y = y * scaleY + m[5];
      }

      vmlElStyle.filter = &#39;&#39;;
      vmlElStyle.left = round(x) + &#39;px&#39;;
      vmlElStyle.top = round(y) + &#39;px&#39;;
    }

    var imageEl = this._imageEl;
    var cropEl = this._cropEl;

    if (!imageEl) {
      imageEl = vmlCore.doc.createElement(&#39;div&#39;);
      this._imageEl = imageEl;
    }

    var imageELStyle = imageEl.style;

    if (hasCrop) {
      // Needs know image original width and height
      if (!(ow &amp;&amp; oh)) {
        var tmpImage = new Image();
        var self = this;

        tmpImage.onload = function () {
          tmpImage.onload = null;
          ow = tmpImage.width;
          oh = tmpImage.height; // Adjust image width and height to fit the ratio destinationSize / sourceSize

          imageELStyle.width = round(scaleX * ow * dw / sw) + &#39;px&#39;;
          imageELStyle.height = round(scaleY * oh * dh / sh) + &#39;px&#39;; // Caching image original width, height and src

          self._imageWidth = ow;
          self._imageHeight = oh;
          self._imageSrc = image;
        };

        tmpImage.src = image;
      } else {
        imageELStyle.width = round(scaleX * ow * dw / sw) + &#39;px&#39;;
        imageELStyle.height = round(scaleY * oh * dh / sh) + &#39;px&#39;;
      }

      if (!cropEl) {
        cropEl = vmlCore.doc.createElement(&#39;div&#39;);
        cropEl.style.overflow = &#39;hidden&#39;;
        this._cropEl = cropEl;
      }

      var cropElStyle = cropEl.style;
      cropElStyle.width = round((dw + sx * dw / sw) * scaleX);
      cropElStyle.height = round((dh + sy * dh / sh) * scaleY);
      cropElStyle.filter = imageTransformPrefix + &#39;.Matrix(Dx=&#39; + -sx * dw / sw * scaleX + &#39;,Dy=&#39; + -sy * dh / sh * scaleY + &#39;)&#39;;

      if (!cropEl.parentNode) {
        vmlEl.appendChild(cropEl);
      }

      if (imageEl.parentNode !== cropEl) {
        cropEl.appendChild(imageEl);
      }
    } else {
      imageELStyle.width = round(scaleX * dw) + &#39;px&#39;;
      imageELStyle.height = round(scaleY * dh) + &#39;px&#39;;
      vmlEl.appendChild(imageEl);

      if (cropEl &amp;&amp; cropEl.parentNode) {
        vmlEl.removeChild(cropEl);
        this._cropEl = null;
      }
    }

    var filterStr = &#39;&#39;;
    var alpha = style.opacity;

    if (alpha &lt; 1) {
      filterStr += &#39;.Alpha(opacity=&#39; + round(alpha * 100) + &#39;) &#39;;
    }

    filterStr += imageTransformPrefix + &#39;.AlphaImageLoader(src=&#39; + image + &#39;, SizingMethod=scale)&#39;;
    imageELStyle.filter = filterStr;
    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root

    append(vmlRoot, vmlEl); // Text

    if (style.text != null) {
      this.drawRectText(vmlRoot, this.getBoundingRect());
    }
  };

  QImage.prototype.onRemove = function (vmlRoot) {
    remove(vmlRoot, this._vmlEl);
    this._vmlEl = null;
    this._cropEl = null;
    this._imageEl = null;
    this.removeRectText(vmlRoot);
  };

  QImage.prototype.onAdd = function (vmlRoot) {
    append(vmlRoot, this._vmlEl);
    this.appendRectText(vmlRoot);
  }; //--------------TEXT----------------------


  var DEFAULT_STYLE_NORMAL = &#39;normal&#39;;
  var fontStyleCache = {};
  var fontStyleCacheCount = 0;
  var MAX_FONT_CACHE_SIZE = 100;
  var fontEl = document.createElement(&#39;div&#39;);

  var getFontStyle = function getFontStyle(fontString) {
    var fontStyle = fontStyleCache[fontString];

    if (!fontStyle) {
      // Clear cache
      if (fontStyleCacheCount &gt; MAX_FONT_CACHE_SIZE) {
        fontStyleCacheCount = 0;
        fontStyleCache = {};
      }

      var style = fontEl.style;
      var fontFamily;

      try {
        style.font = fontString;
        fontFamily = style.fontFamily.split(&#39;,&#39;)[0];
      } catch (e) {}

      fontStyle = {
        style: style.fontStyle || DEFAULT_STYLE_NORMAL,
        variant: style.fontVariant || DEFAULT_STYLE_NORMAL,
        weight: style.fontWeight || DEFAULT_STYLE_NORMAL,
        size: parseFloat(style.fontSize || 12) | 0,
        family: fontFamily || &#39;Microsoft YaHei&#39;
      };
      fontStyleCache[fontString] = fontStyle;
      fontStyleCacheCount++;
    }

    return fontStyle;
  };

  var textMeasureEl; // Overwrite measure text method

  textContain.$override(&#39;measureText&#39;, function (text, textFont) {
    var doc = vmlCore.doc;

    if (!textMeasureEl) {
      textMeasureEl = doc.createElement(&#39;div&#39;);
      textMeasureEl.style.cssText = &#39;position:absolute;top:-20000px;left:0;&#39; + &#39;padding:0;margin:0;border:none;white-space:pre;&#39;;
      vmlCore.doc.body.appendChild(textMeasureEl);
    }

    try {
      textMeasureEl.style.font = textFont;
    } catch (ex) {// Ignore failures to set to invalid font.
    }

    textMeasureEl.innerHTML = &#39;&#39;; // Don&#39;t use innerHTML or innerText because they allow markup/whitespace.

    textMeasureEl.appendChild(doc.createTextNode(text));
    return {
      width: textMeasureEl.offsetWidth
    };
  });
  var tmpRect = new BoundingRect();

  var drawRectText = function drawRectText(vmlRoot, rect, textRect, fromTextEl) {
    var style = this.style; // Optimize, avoid normalize every time.

    this.__dirty &amp;&amp; textUtil.normalizeTextStyle(style, true);
    var text = style.text; // Convert to string

    text != null &amp;&amp; (text += &#39;&#39;);

    if (!text) {
      return;
    } // Convert rich text to plain text. Rich text is not supported in
    // IE8-, but tags in rich text template will be removed.


    if (style.rich) {
      var contentBlock = textContain.parseRichText(text, style);
      text = [];

      for (var i = 0; i &lt; contentBlock.lines.length; i++) {
        var tokens = contentBlock.lines[i].tokens;
        var textLine = [];

        for (var j = 0; j &lt; tokens.length; j++) {
          textLine.push(tokens[j].text);
        }

        text.push(textLine.join(&#39;&#39;));
      }

      text = text.join(&#39;\n&#39;);
    }

    var x;
    var y;
    var align = style.textAlign;
    var verticalAlign = style.textVerticalAlign;
    var fontStyle = getFontStyle(style.font); // FIXME encodeHtmlAttribute ?

    var font = fontStyle.style + &#39; &#39; + fontStyle.variant + &#39; &#39; + fontStyle.weight + &#39; &#39; + fontStyle.size + &#39;px &quot;&#39; + fontStyle.family + &#39;&quot;&#39;;
    textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign, style.textPadding, style.textLineHeight); // Transform rect to view space

    var m = this.transform; // Ignore transform for text in other element

    if (m &amp;&amp; !fromTextEl) {
      tmpRect.copy(rect);
      tmpRect.applyTransform(m);
      rect = tmpRect;
    }

    if (!fromTextEl) {
      var textPosition = style.textPosition; // Text position represented by coord

      if (textPosition instanceof Array) {
        x = rect.x + parsePercent(textPosition[0], rect.width);
        y = rect.y + parsePercent(textPosition[1], rect.height);
        align = align || &#39;left&#39;;
      } else {
        var res = this.calculateTextPosition ? this.calculateTextPosition({}, style, rect) : textContain.calculateTextPosition({}, style, rect);
        x = res.x;
        y = res.y; // Default align and baseline when has textPosition

        align = align || res.textAlign;
        verticalAlign = verticalAlign || res.textVerticalAlign;
      }
    } else {
      x = rect.x;
      y = rect.y;
    }

    x = textContain.adjustTextX(x, textRect.width, align);
    y = textContain.adjustTextY(y, textRect.height, verticalAlign); // Force baseline &#39;middle&#39;

    y += textRect.height / 2; // let fontSize = fontStyle.size;
    // 1.75 is an arbitrary number, as there is no info about the text baseline
    // switch (baseline) {
    // case &#39;hanging&#39;:
    // case &#39;top&#39;:
    //     y += fontSize / 1.75;
    //     break;
    //     case &#39;middle&#39;:
    //         break;
    //     default:
    //     // case null:
    //     // case &#39;alphabetic&#39;:
    //     // case &#39;ideographic&#39;:
    //     // case &#39;bottom&#39;:
    //         y -= fontSize / 2.25;
    //         break;
    // }
    // switch (align) {
    //     case &#39;left&#39;:
    //         break;
    //     case &#39;center&#39;:
    //         x -= textRect.width / 2;
    //         break;
    //     case &#39;right&#39;:
    //         x -= textRect.width;
    //         break;
    // case &#39;end&#39;:
    // align = elementStyle.direction == &#39;ltr&#39; ? &#39;right&#39; : &#39;left&#39;;
    // break;
    // case &#39;start&#39;:
    // align = elementStyle.direction == &#39;rtl&#39; ? &#39;right&#39; : &#39;left&#39;;
    // break;
    // default:
    //     align = &#39;left&#39;;
    // }

    var createNode = vmlCore.createNode;
    var textVmlEl = this._textVmlEl;
    var pathEl;
    var textPathEl;
    var skewEl;

    if (!textVmlEl) {
      textVmlEl = createNode(&#39;line&#39;);
      pathEl = createNode(&#39;path&#39;);
      textPathEl = createNode(&#39;textpath&#39;);
      skewEl = createNode(&#39;skew&#39;); // FIXME Why here is not cammel case
      // Align &#39;center&#39; seems wrong

      textPathEl.style[&#39;v-text-align&#39;] = &#39;left&#39;;
      initRootElStyle(textVmlEl);
      pathEl.textpathok = true;
      textPathEl.on = true;
      textVmlEl.from = &#39;0 0&#39;;
      textVmlEl.to = &#39;1000 0.05&#39;;
      append(textVmlEl, skewEl);
      append(textVmlEl, pathEl);
      append(textVmlEl, textPathEl);
      this._textVmlEl = textVmlEl;
    } else {
      // 这里是在前面 appendChild 保证顺序的前提下
      skewEl = textVmlEl.firstChild;
      pathEl = skewEl.nextSibling;
      textPathEl = pathEl.nextSibling;
    }

    var coords = [x, y];
    var textVmlElStyle = textVmlEl.style; // Ignore transform for text in other element

    if (m &amp;&amp; fromTextEl) {
      applyTransform(coords, coords, m);
      skewEl.on = true;
      skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + &#39;,0,0&#39;; // Text position

      skewEl.offset = (round(coords[0]) || 0) + &#39;,&#39; + (round(coords[1]) || 0); // Left top point as origin

      skewEl.origin = &#39;0 0&#39;;
      textVmlElStyle.left = &#39;0px&#39;;
      textVmlElStyle.top = &#39;0px&#39;;
    } else {
      skewEl.on = false;
      textVmlElStyle.left = round(x) + &#39;px&#39;;
      textVmlElStyle.top = round(y) + &#39;px&#39;;
    }

    textPathEl.string = encodeHtmlAttribute(text); // TODO

    try {
      textPathEl.style.font = font;
    } // Error font format
    catch (e) {}

    updateFillAndStroke(textVmlEl, &#39;fill&#39;, {
      fill: style.textFill,
      opacity: style.opacity
    }, this);
    updateFillAndStroke(textVmlEl, &#39;stroke&#39;, {
      stroke: style.textStroke,
      opacity: style.opacity,
      lineDash: style.lineDash || null // style.lineDash can be `false`.

    }, this);
    textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Attached to root

    append(vmlRoot, textVmlEl);
  };

  var removeRectText = function removeRectText(vmlRoot) {
    remove(vmlRoot, this._textVmlEl);
    this._textVmlEl = null;
  };

  var appendRectText = function appendRectText(vmlRoot) {
    append(vmlRoot, this._textVmlEl);
  };

  var list = [RectText, Displayable, QImage, Path, Text]; // In case Displayable has been mixed in RectText

  for (var i = 0; i &lt; list.length; i++) {
    var proto = list[i].prototype;
    proto.drawRectText = drawRectText;
    proto.removeRectText = removeRectText;
    proto.appendRectText = appendRectText;
  }
<span id='qrenderer-vml-Text'>  /**
</span>   * @class qrenderer.vml.Text
   * 
   * @docauthor 大漠穷秋 damoqiongqiu@126.com
   */


  Text.prototype.brushVML = function (vmlRoot) {
    var style = this.style;

    if (style.text != null) {
      this.drawRectText(vmlRoot, {
        x: style.x || 0,
        y: style.y || 0,
        width: 0,
        height: 0
      }, this.getBoundingRect(), true);
    } else {
      this.removeRectText(vmlRoot);
    }
  };

  Text.prototype.onRemove = function (vmlRoot) {
    this.removeRectText(vmlRoot);
  };

  Text.prototype.onAdd = function (vmlRoot) {
    this.appendRectText(vmlRoot);
  };
}</pre>
</body>
</html>
