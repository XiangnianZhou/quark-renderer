<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">var Displayable = require(&quot;./Displayable&quot;);

var dataUtil = require(&quot;../core/utils/dataStructureUtil&quot;);

var textContain = require(&quot;../core/contain/text&quot;);

var textHelper = require(&quot;./utils/text&quot;);

var _constants = require(&quot;./constants&quot;);

var ContextCachedBy = _constants.ContextCachedBy;

<span id='zrender-graphic-Text'>/**
</span> * @class zrender.graphic.Text
 * 
 * @docauthor 大漠穷秋 &lt;damoqiongqiu@126.com&gt;
 */

<span id='zrender-graphic-Text-method-constructor'>/**
</span> * @method constructor Text
 * @param {Object} opts 
 */
var Text = function Text(opts) {
  // jshint ignore:line
  Displayable.call(this, opts);
};

Text.prototype = {
  constructor: Text,
  type: &#39;text&#39;,
  brush: function brush(ctx, prevEl) {
    var style = this.style; // Optimize, avoid normalize every time.

    this.__dirty &amp;&amp; textHelper.normalizeTextStyle(style, true); // Use props with prefix &#39;text&#39;.

    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;
    var text = style.text; // Convert to string

    text != null &amp;&amp; (text += &#39;&#39;); // Do not apply style.bind in Text node. Because the real bind job
    // is in textHelper.renderText, and performance of text render should
    // be considered.
    // style.bind(ctx, this, prevEl);

    if (!textHelper.needDrawText(text, style)) {
      // The current el.style is not applied
      // and should not be used as cache.
      ctx.__attrCachedBy = ContextCachedBy.NONE;
      return;
    }

    this.setTransform(ctx);
    textHelper.renderText(this, ctx, text, style, null, prevEl);
    this.restoreTransform(ctx);
  },
  getBoundingRect: function getBoundingRect() {
    var style = this.style; // Optimize, avoid normalize every time.

    this.__dirty &amp;&amp; textHelper.normalizeTextStyle(style, true);

    if (!this._rect) {
      var text = style.text;
      text != null ? text += &#39;&#39; : text = &#39;&#39;;
      var rect = textContain.getBoundingRect(style.text + &#39;&#39;, style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.textLineHeight, style.rich);
      rect.x += style.x || 0;
      rect.y += style.y || 0;

      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {
        var w = style.textStrokeWidth;
        rect.x -= w / 2;
        rect.y -= w / 2;
        rect.width += w;
        rect.height += w;
      }

      this._rect = rect;
    }

    return this._rect;
  }
};
dataUtil.inherits(Text, Displayable);
var _default = Text;
module.exports = _default;</pre>
</body>
</html>
