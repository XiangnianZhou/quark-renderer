<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">var requestAnimationFrame = require(&quot;./animation/utils/request_animation_frame&quot;);

var _config = require(&quot;./config&quot;);

var devicePixelRatio = _config.devicePixelRatio;

var dataUtil = require(&quot;./core/utils/data_structure_util&quot;);

var BoundingRect = require(&quot;./graphic/transform/BoundingRect&quot;);

var timsort = require(&quot;./core/utils/timsort&quot;);

var CanvasLayer = require(&quot;./CanvasLayer&quot;);

var Image = require(&quot;./graphic/Image&quot;);

var env = require(&quot;./core/env&quot;);

var _constants = require(&quot;./graphic/constants&quot;);

var mathRandom = _constants.mathRandom;
var mathMax = _constants.mathMax;

var canvasUtil = require(&quot;./core/utils/canvas_util&quot;);

var guid = require(&quot;./core/utils/guid&quot;);

<span id='qrenderer-canvas-CanvasPainter'>/**
</span> * @class qrenderer.canvas.CanvasPainter
 * 这是基于 canvas 接口的 CanvasPainter 类
 * @see 基于 SVG 接口的 CanvasPainter 类在 svg 目录下
 * @see 基于 VML 接口的 CanvasPainter 类在 vml 目录下
 */
var HOVER_LAYER_QLEVEL = 1e5;
var CANVAS_QLEVEL = 314159;
var EL_AFTER_INCREMENTAL_INC = 0.01;
var INCREMENTAL_INC = 0.001;
<span id='qrenderer-canvas-CanvasPainter-method-isLayerValid'>/**
</span> * @private
 * @method isLayerValid
 * @param {*} layer 
 */

function isLayerValid(layer) {
  if (!layer) {
    return false;
  }

  if (layer.__builtin__) {
    return true;
  }

  if (typeof layer.resize !== &#39;function&#39; || typeof layer.refresh !== &#39;function&#39;) {
    return false;
  }

  return true;
}

var tmpRect = new BoundingRect(0, 0, 0, 0);
var viewRect = new BoundingRect(0, 0, 0, 0);
<span id='qrenderer-canvas-CanvasPainter-method-isDisplayableCulled'>/**
</span> * @private
 * @method isDisplayableCulled
 * @param {*} el 
 * @param {*} width 
 * @param {*} height 
 */

function isDisplayableCulled(el, width, height) {
  tmpRect.copy(el.getBoundingRect());

  if (el.transform) {
    tmpRect.applyTransform(el.transform);
  }

  viewRect.width = width;
  viewRect.height = height;
  return !tmpRect.intersect(viewRect);
}
<span id='qrenderer-canvas-CanvasPainter-method-isClipPathChanged'>/**
</span> * @private
 * @method isClipPathChanged
 * @param {*} clipPaths 
 * @param {*} prevClipPaths 
 */


function isClipPathChanged(clipPaths, prevClipPaths) {
  // displayable.__clipPaths can only be `null`/`undefined` or an non-empty array.
  if (clipPaths === prevClipPaths) {
    return false;
  }

  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
    return true;
  }

  for (var i = 0; i &lt; clipPaths.length; i++) {
    if (clipPaths[i] !== prevClipPaths[i]) {
      return true;
    }
  }

  return false;
}
<span id='qrenderer-canvas-CanvasPainter-method-doClip'>/**
</span> * @private
 * @method doClip
 * @param {*} clipPaths 
 * @param {*} ctx 
 */


function doClip(clipPaths, ctx) {
  for (var i = 0; i &lt; clipPaths.length; i++) {
    var clipPath = clipPaths[i];
    clipPath.setTransform(ctx);
    ctx.beginPath();
    clipPath.buildPath(ctx, clipPath.shape);
    ctx.clip(); // Transform back

    clipPath.restoreTransform(ctx);
  }
}
<span id='qrenderer-canvas-CanvasPainter-method-createDomRoot'>/**
</span> * @private
 * @method createDomRoot
 * 不会直接在传入的 dom 节点内部创建 canvas 标签，而是再套一层div
 * 目的是加上一些必须的 CSS 样式，方便实现特定的功能。
 * @param {Number} width 
 * @param {Number} height 
 */


function createDomRoot(width, height) {
  var domRoot = document.createElement(&#39;div&#39;); // domRoot.onselectstart = returnFalse; // Avoid page selected

  domRoot.style.cssText = [&#39;position:relative&#39;, // IOS13 safari probably has a compositing bug (z order of the canvas and the consequent
  // dom does not act as expected) when some of the parent dom has
  // `-webkit-overflow-scrolling: touch;` and the webpage is longer than one screen and
  // the canvas is not at the top part of the page.
  // Check `https://bugs.webkit.org/show_bug.cgi?id=203681` for more details. We remove
  // this `overflow:hidden` to avoid the bug.
  // &#39;overflow:hidden&#39;,
  &#39;width:&#39; + width + &#39;px&#39;, &#39;height:&#39; + height + &#39;px&#39;, &#39;padding:0&#39;, &#39;margin:0&#39;, &#39;border-width:0&#39;].join(&#39;;&#39;) + &#39;;&#39;; //为了让div能够响应键盘事件，这个属性是必须的
  // domRoot.setAttribute(&quot;tabindex&quot;,&quot;0&quot;);

  return domRoot;
}
<span id='qrenderer-canvas-CanvasPainter-method-constructor'>/**
</span> * @method constructor
 * @param {HTMLElement} root 绘图容器
 * @param {Storage} storage
 * @param {Object} options
 */


var CanvasPainter = function CanvasPainter(root, storage, options) {
  this.type = &#39;canvas&#39;; // In node environment using node-canvas

  var singleCanvas = !root.nodeName // In node ?
  || root.nodeName.toUpperCase() === &#39;CANVAS&#39;;
  this._opts = options = dataUtil.extend({}, options || {});
<span id='qrenderer-canvas-CanvasPainter-property-dpr'>  /**
</span>   * @property {Number} dpr
   */

  this.dpr = options.devicePixelRatio || devicePixelRatio;
<span id='qrenderer-canvas-CanvasPainter-property-_singleCanvas'>  /**
</span>   * @property {Boolean} _singleCanvas
   * @private
   */

  this._singleCanvas = singleCanvas;
<span id='qrenderer-canvas-CanvasPainter-property-root'>  /**
</span>   * @property {HTMLElement} root 绘图容器
   */

  this.root = root; // There is no style attribute on element in nodejs.

  if (this.root.style) {
    this.root.style[&#39;-webkit-tap-highlight-color&#39;] = &#39;transparent&#39;;
    this.root.style[&#39;-webkit-user-select&#39;] = this.root.style[&#39;user-select&#39;] = this.root.style[&#39;-webkit-touch-callout&#39;] = &#39;none&#39;;
    root.innerHTML = &#39;&#39;;
  }
<span id='qrenderer-canvas-CanvasPainter-property-_domRoot'>  /**
</span>   * @private
   * @property {HTMLElement} _domRoot 绘图容器，或者 Canvas 实例
   */


  this._domRoot = null;
<span id='qrenderer-canvas-CanvasPainter-property-storage'>  /**
</span>   * @property {Storage} storage
   */

  this.storage = storage;
<span id='qrenderer-canvas-CanvasPainter-property-qlevelList'>  /**
</span>   * @property {Array&lt;Number&gt;}
   * @private
   */

  var qlevelList = this._qlevelList = [];
<span id='qrenderer-canvas-CanvasPainter-property-layers'>  /**
</span>   * @private
   * @property {Object&lt;String, CanvasLayer&gt;} layers
   */

  var layers = this._layers = {};
<span id='qrenderer-canvas-CanvasPainter-property-_layerConfig'>  /**
</span>   * @private
   * @property {Object&lt;String, Object&gt;} _layerConfig
   */

  this._layerConfig = {};
<span id='qrenderer-canvas-CanvasPainter-property-_needsManuallyCompositing'>  /**
</span>   * @private
   * @property _needsManuallyCompositing
   * qrenderer will do compositing when root is a canvas and have multiple zlevels.
   */

  this._needsManuallyCompositing = false;

  if (!singleCanvas) {
    this._width = this._getSize(0);
    this._height = this._getSize(1);
    var domRoot = createDomRoot( // Craete a new div inside the root element.
    this._width, this._height);
    this._domRoot = domRoot; // In this case, this._domRoot is different from this.root.

    root.appendChild(domRoot);
  } else {
    var width = root.width;
    var height = root.height;

    if (options.width != null) {
      width = options.width;
    }

    if (options.height != null) {
      height = options.height;
    }

    this.dpr = options.devicePixelRatio || 1; // Use canvas width and height directly

    root.width = width * this.dpr;
    root.height = height * this.dpr;
    this._width = width;
    this._height = height; // Create layer if only one given canvas
    // Device can be specified to create a high dpi image.

    var mainLayer = new CanvasLayer(root, this._width, this._height, this.dpr);
    mainLayer.__builtin__ = true;
    mainLayer.initContext(); // FIXME Use canvas width and height
    // mainLayer.resize(width, height);

    layers[CANVAS_QLEVEL] = mainLayer;
    mainLayer.qlevel = CANVAS_QLEVEL; // Not use common qlevel.

    qlevelList.push(CANVAS_QLEVEL);
    this._domRoot = root; // Here, this._domRoot equals this.root.
  }
<span id='qrenderer-canvas-CanvasPainter-property-_hoverlayer'>  /**
</span>   * @private
   * @property {CanvasLayer} _hoverlayer
   */


  this._hoverlayer = null;
<span id='qrenderer-canvas-CanvasPainter-property-_hoverElements'>  /**
</span>   * @private
   * @property {Array} _hoverElements
   */

  this._hoverElements = [];
};

CanvasPainter.prototype = {
  constructor: CanvasPainter,

<span id='qrenderer-canvas-CanvasPainter-method-getType'>  /**
</span>   * @method getType
   * @return {String}
   */
  getType: function getType() {
    return &#39;canvas&#39;;
  },

<span id='qrenderer-canvas-CanvasPainter-method-isSingleCanvas'>  /**
</span>   * @method isSingleCanvas
   * If painter use a single canvas
   * @return {Boolean}
   */
  isSingleCanvas: function isSingleCanvas() {
    return this._singleCanvas;
  },

<span id='qrenderer-canvas-CanvasPainter-method-getViewportRoot'>  /**
</span>   * @method getViewportRoot
   * @return {HTMLDivElement}
   */
  getViewportRoot: function getViewportRoot() {
    return this._domRoot;
  },

<span id='qrenderer-canvas-CanvasPainter-method-getViewportRootOffset'>  /**
</span>   * @method getViewportRootOffset
   * @return {Object}
   */
  getViewportRootOffset: function getViewportRootOffset() {
    var viewportRoot = this.getViewportRoot();

    if (viewportRoot) {
      return {
        offsetLeft: viewportRoot.offsetLeft || 0,
        offsetTop: viewportRoot.offsetTop || 0
      };
    }
  },

<span id='qrenderer-canvas-CanvasPainter-method-refresh'>  /**
</span>   * @method
   * 刷新
   * @param {Boolean} [paintAll=false] 是否强制绘制所有displayable
   */
  refresh: function refresh(paintAll) {
    var list = this.storage.getDisplayList(true);
    var qlevelList = this._qlevelList;
    this._redrawId = mathRandom();

    this._paintList(list, paintAll, this._redrawId); // Paint custum layers


    for (var i = 0; i &lt; qlevelList.length; i++) {
      var z = qlevelList[i];
      var layer = this._layers[z];

      if (!layer.__builtin__ &amp;&amp; layer.refresh) {
        var clearColor = i === 0 ? this._backgroundColor : null;
        layer.refresh(clearColor);
      }
    }

    this.refreshHover();
    return this;
  },

<span id='qrenderer-canvas-CanvasPainter-method-addHover'>  /**
</span>   * @method addHover
   * 
   * @param {*} el 
   * @param {*} hoverStyle 
   */
  addHover: function addHover(el, hoverStyle) {
    if (el.__hoverMir) {
      return;
    }

    var elMirror = new el.constructor({
      style: el.style,
      shape: el.shape,
      z: el.z,
      z2: el.z2,
      silent: el.silent
    });
    elMirror.__from = el;
    el.__hoverMir = elMirror;
    hoverStyle &amp;&amp; elMirror.setStyle(hoverStyle);

    this._hoverElements.push(elMirror);

    return elMirror;
  },

<span id='qrenderer-canvas-CanvasPainter-method-removeHover'>  /**
</span>   * @method removeHover
   * @param {*} el 
   */
  removeHover: function removeHover(el) {
    var elMirror = el.__hoverMir;
    var hoverElements = this._hoverElements;
    var idx = dataUtil.indexOf(hoverElements, elMirror);

    if (idx &gt;= 0) {
      hoverElements.splice(idx, 1);
    }

    el.__hoverMir = null;
  },

<span id='qrenderer-canvas-CanvasPainter-method-clearHover'>  /**
</span>   * @method clearHover
   * @param {*} el 
   */
  clearHover: function clearHover(el) {
    var hoverElements = this._hoverElements;

    for (var i = 0; i &lt; hoverElements.length; i++) {
      var from = hoverElements[i].__from;

      if (from) {
        from.__hoverMir = null;
      }
    }

    hoverElements.length = 0;
  },

<span id='qrenderer-canvas-CanvasPainter-method-refreshHover'>  /**
</span>   * @method refreshHover
   */
  refreshHover: function refreshHover() {
    var hoverElements = this._hoverElements;
    var len = hoverElements.length;
    var hoverLayer = this._hoverlayer;
    hoverLayer &amp;&amp; hoverLayer.clear();

    if (!len) {
      return;
    }

    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large qlevel
    // FIXME?

    if (!hoverLayer) {
      hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_QLEVEL);
    }

    var scope = {};
    hoverLayer.ctx.save();

    for (var i = 0; i &lt; len;) {
      var el = hoverElements[i];
      var originalEl = el.__from; // Original el is removed
      // PENDING

      if (!(originalEl &amp;&amp; originalEl.__qr)) {
        hoverElements.splice(i, 1);
        originalEl.__hoverMir = null;
        len--;
        continue;
      }

      i++; // Use transform
      // FIXME style and shape ?

      if (!originalEl.invisible) {
        el.transform = originalEl.transform;
        el.invTransform = originalEl.invTransform;
        el.__clipPaths = originalEl.__clipPaths; // el.

        this._doPaintEl(el, hoverLayer, true, scope);
      }
    }

    hoverLayer.ctx.restore();
  },

<span id='qrenderer-canvas-CanvasPainter-method-getHoverLayer'>  /**
</span>   * @method getHoverLayer
   */
  getHoverLayer: function getHoverLayer() {
    return this.getLayer(HOVER_LAYER_QLEVEL);
  },

<span id='qrenderer-canvas-CanvasPainter-method-_paintList'>  /**
</span>   * @method _paintList
   * @param {*} list 
   * @param {*} paintAll 
   * @param {*} redrawId 
   */
  _paintList: function _paintList(list, paintAll, redrawId) {
    //如果 redrawId 不一致，说明下一个动画帧已经到来，这里就会直接跳过去，相当于跳过了一帧
    if (this._redrawId !== redrawId) {
      return;
    }

    paintAll = paintAll || false;

    this._updateLayerStatus(list);

    var finished = this._doPaintList(list, paintAll);

    if (this._needsManuallyCompositing) {
      this._compositeManually();
    } //如果在一帧的时间内没有绘制完，在下一帧继续绘制
    //TODO:这里需要测试一个极限值出来，在 16ms 的时间里面最多能绘制多少个元素。


    if (!finished) {
      var self = this;
      requestAnimationFrame(function () {
        self._paintList(list, paintAll, redrawId);
      });
    }
  },

<span id='qrenderer-canvas-CanvasPainter-method-_compositeManually'>  /**
</span>   * @method _compositeManually
   */
  _compositeManually: function _compositeManually() {
    var ctx = this.getLayer(CANVAS_QLEVEL).ctx;
    var width = this._domRoot.width;
    var height = this._domRoot.height;
    ctx.clearRect(0, 0, width, height); // PENDING, If only builtin layer?

    this.eachBuiltinLayer(function (layer) {
      if (layer.virtual) {
        ctx.drawImage(layer.canvasInstance, 0, 0, width, height);
      }
    });
  },

<span id='qrenderer-canvas-CanvasPainter-method-_doPaintList'>  /**
</span>   * @method _doPaintList
   */
  _doPaintList: function _doPaintList(list, paintAll) {
    var layerList = [];

    for (var zi = 0; zi &lt; this._qlevelList.length; zi++) {
      var qlevel = this._qlevelList[zi];
      var layer = this._layers[qlevel];

      if (layer.__builtin__ &amp;&amp; layer !== this._hoverlayer &amp;&amp; (layer.__dirty || paintAll)) {
        layerList.push(layer);
      }
    }

    var finished = true;

    for (var k = 0; k &lt; layerList.length; k++) {
      var _layer = layerList[k];
      var ctx = _layer.ctx;
      var scope = {};
      ctx.save();
      var start = paintAll ? _layer.__startIndex : _layer.__drawIndex;
      var useTimer = !paintAll &amp;&amp; _layer.incremental &amp;&amp; Date.now;
      var startTime = useTimer &amp;&amp; Date.now();
      var clearColor = _layer.qlevel === this._qlevelList[0] ? this._backgroundColor : null; // All elements in this layer are cleared.

      if (_layer.__startIndex === _layer.__endIndex) {
        _layer.clear(false, clearColor);
      } else if (start === _layer.__startIndex) {
        var firstEl = list[start];

        if (!firstEl.incremental || !firstEl.notClear || paintAll) {
          _layer.clear(false, clearColor);
        }
      }

      if (start === -1) {
        console.error(&#39;For some unknown reason. drawIndex is -1&#39;);
        start = _layer.__startIndex;
      }

      var i = start;

      for (; i &lt; _layer.__endIndex; i++) {
        var el = list[i];

        this._doPaintEl(el, _layer, paintAll, scope);

        el.__dirty = el.__dirtyText = false;

        if (useTimer) {
          // Date.now can be executed in 13,025,305 ops/second.
          var dTime = Date.now() - startTime; // Give 15 millisecond to draw.
          // The rest elements will be drawn in the next frame.
          // 这里的时间计算非常重要，如果 15ms 的时间内没有能绘制完所有元素，则跳出，等待下一帧继续绘制
          // 但是 15ms 的时间依然是有限的，如果元素的数量非常巨大，例如有 1000 万个，还是会卡顿。
          // TODO: 这里需要实际 benchmark 一个数值出来。

          if (dTime &gt; 15) {
            break;
          }
        }
      }

      _layer.__drawIndex = i;

      if (_layer.__drawIndex &lt; _layer.__endIndex) {
        finished = false;
      }

      if (scope.prevElClipPaths) {
        // Needs restore the state. If last drawn element is in the clipping area.
        ctx.restore();
      }

      ctx.restore();
    }

    if (env.wxa) {
      // Flush for weixin application
      dataUtil.each(this._layers, function (layer) {
        if (layer &amp;&amp; layer.ctx &amp;&amp; layer.ctx.draw) {
          layer.ctx.draw();
        }
      });
    }

    return finished;
  },

<span id='qrenderer-canvas-CanvasPainter-method-_doPaintEl'>  /**
</span>   * @method _doPaintEl
   * 绘制一个元素
   * @param {*} el 
   * @param {*} currentLayer 
   * @param {*} forcePaint 
   * @param {*} scope 
   */
  _doPaintEl: function _doPaintEl(el, currentLayer, forcePaint, scope) {
    var ctx = currentLayer.ctx;
    var m = el.transform;

    if ((currentLayer.__dirty || forcePaint) &amp;&amp; // Ignore invisible element
    !el.invisible // Ignore transparent element
    &amp;&amp; el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas
    // Draw a scale 0 element can cause all following draw wrong
    // And setTransform with scale 0 will cause set back transform failed.
    &amp;&amp; !(m &amp;&amp; !m[0] &amp;&amp; !m[3]) // Ignore culled element
    &amp;&amp; !(el.culling &amp;&amp; isDisplayableCulled(el, this._width, this._height))) {
      var clipPaths = el.__clipPaths;
      var prevElClipPaths = scope.prevElClipPaths; // Optimize when clipping on group with several elements

      if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {
        // If has previous clipping state, restore from it
        if (prevElClipPaths) {
          ctx.restore();
          scope.prevElClipPaths = null; // Reset prevEl since context has been restored

          scope.prevEl = null;
        } // New clipping state


        if (clipPaths) {
          ctx.save();
          doClip(clipPaths, ctx);
          scope.prevElClipPaths = clipPaths;
        }
      } //开始绘制元素，beforeBrush/brush/afterBrush 3个方法定义在基类 Displayable 中。
      //每个元素自己知道如何绘制自身的形状。


      el.beforeBrush &amp;&amp; el.beforeBrush(ctx);
      el.brush(ctx, scope.prevEl || null);
      scope.prevEl = el;
      el.afterBrush &amp;&amp; el.afterBrush(ctx);
    }
  },

<span id='qrenderer-canvas-CanvasPainter-method-getLayer'>  /**
</span>   * @method getLayer
   * 获取 qlevel 所在层，如果不存在则会创建一个新的层
   * @param {Number} qlevel
   * @param {Boolean} virtual Virtual layer will not be inserted into dom.
   * @return {CanvasLayer}
   */
  getLayer: function getLayer(qlevel, virtual) {
    if (this._singleCanvas &amp;&amp; !this._needsManuallyCompositing) {
      qlevel = CANVAS_QLEVEL;
    }

    var layer = this._layers[qlevel];

    if (!layer) {
      // Create a new layer
      layer = new CanvasLayer(&#39;qr_&#39; + qlevel, this._width, this._height, this.dpr);
      layer.qlevel = qlevel;
      layer.__builtin__ = true;

      if (this._layerConfig[qlevel]) {
        dataUtil.merge(layer, this._layerConfig[qlevel], true);
      }

      if (virtual) {
        layer.virtual = virtual;
      }

      this.insertLayer(qlevel, layer); // Context is created after dom inserted to document
      // Or excanvas will get 0px clientWidth and clientHeight

      layer.initContext();
    }

    return layer;
  },

<span id='qrenderer-canvas-CanvasPainter-method-insertLayer'>  /**
</span>   * @method insertLayer
   * @param {*} qlevel 
   * @param {*} layer 
   */
  insertLayer: function insertLayer(qlevel, layer) {
    var layersMap = this._layers;
    var qlevelList = this._qlevelList;
    var len = qlevelList.length;
    var prevLayer = null;
    var i = -1;
    var domRoot = this._domRoot;

    if (layersMap[qlevel]) {
      console.log(&#39;ZLevel &#39; + qlevel + &#39; has been used already&#39;);
      return;
    } // Check if is a valid layer


    if (!isLayerValid(layer)) {
      console.log(&#39;CanvasLayer of qlevel &#39; + qlevel + &#39; is not valid&#39;);
      return;
    }

    if (len &gt; 0 &amp;&amp; qlevel &gt; qlevelList[0]) {
      for (i = 0; i &lt; len - 1; i++) {
        if (qlevelList[i] &lt; qlevel &amp;&amp; qlevelList[i + 1] &gt; qlevel) {
          break;
        }
      }

      prevLayer = layersMap[qlevelList[i]];
    }

    qlevelList.splice(i + 1, 0, qlevel);
    layersMap[qlevel] = layer; // Vitual layer will not directly show on the screen.
    // (It can be a WebGL layer and assigned to a ZImage element)
    // But it still under management of qrenderer.

    if (!layer.virtual) {
      if (prevLayer) {
        var prevDom = prevLayer.dom;

        if (prevDom.nextSibling) {
          domRoot.insertBefore(layer.canvasInstance, prevDom.nextSibling);
        } else {
          domRoot.appendChild(layer.canvasInstance);
        }
      } else {
        if (domRoot.firstChild) {
          domRoot.insertBefore(layer.canvasInstance, domRoot.firstChild);
        } else {
          domRoot.appendChild(layer.canvasInstance);
        }
      }
    }
  },

<span id='qrenderer-canvas-CanvasPainter-method-delLayer'>  /**
</span>   * @method delLayer
   * 删除指定层
   * @param {Number} qlevel 层所在的zlevel
   */
  delLayer: function delLayer(qlevel) {
    var layers = this._layers;
    var qlevelList = this._qlevelList;
    var layer = layers[qlevel];

    if (!layer) {
      return;
    }

    layer.canvasInstance.parentNode.removeChild(layer.canvasInstance);
    delete layers[qlevel];
    qlevelList.splice(dataUtil.indexOf(qlevelList, qlevel), 1);
  },

<span id='qrenderer-canvas-CanvasPainter-method-eachLayer'>  /**
</span>   * @private
   * @method eachLayer
   * Iterate each layer
   * @param {Function} cb 
   * @param {Object} context 
   */
  eachLayer: function eachLayer(cb, context) {
    var qlevelList = this._qlevelList;
    var z;
    var i;

    for (i = 0; i &lt; qlevelList.length; i++) {
      z = qlevelList[i];
      cb.call(context, this._layers[z], z);
    }
  },

<span id='qrenderer-canvas-CanvasPainter-method-eachBuiltinLayer'>  /**
</span>   * @private
   * @method eachBuiltinLayer
   * Iterate each buildin layer
   * @param {Function} cb 
   * @param {Object} context 
   */
  eachBuiltinLayer: function eachBuiltinLayer(cb, context) {
    var qlevelList = this._qlevelList;
    var layer;
    var z;
    var i;

    for (i = 0; i &lt; qlevelList.length; i++) {
      z = qlevelList[i];
      layer = this._layers[z];

      if (layer.__builtin__) {
        cb.call(context, layer, z);
      }
    }
  },

<span id='qrenderer-canvas-CanvasPainter-method-eachOtherLayer'>  /**
</span>   * @private
   * @method eachOtherLayer
   * Iterate each other layer except buildin layer
   * @param {Function} cb 
   * @param {Object} context 
   */
  eachOtherLayer: function eachOtherLayer(cb, context) {
    var qlevelList = this._qlevelList;
    var layer;
    var z;
    var i;

    for (i = 0; i &lt; qlevelList.length; i++) {
      z = qlevelList[i];
      layer = this._layers[z];

      if (!layer.__builtin__) {
        cb.call(context, layer, z);
      }
    }
  },

<span id='qrenderer-canvas-CanvasPainter-method-getLayers'>  /**
</span>   * @method getLayers
   * 获取所有已创建的层
   * @param {Array&lt;CanvasLayer&gt;} [prevLayer]
   */
  getLayers: function getLayers() {
    return this._layers;
  },

<span id='qrenderer-canvas-CanvasPainter-method-_updateLayerStatus'>  /**
</span>   * @private
   * @method _updateLayerStatus
   * @param {*} list 
   */
  _updateLayerStatus: function _updateLayerStatus(list) {
    this.eachBuiltinLayer(function (layer, z) {
      layer.__dirty = layer.__used = false;
    });

    function updatePrevLayer(idx) {
      if (prevLayer) {
        if (prevLayer.__endIndex !== idx) {
          prevLayer.__dirty = true;
        }

        prevLayer.__endIndex = idx;
      }
    }

    if (this._singleCanvas) {
      for (var _i = 1; _i &lt; list.length; _i++) {
        var el = list[_i];

        if (el.qlevel !== list[_i - 1].qlevel || el.incremental) {
          this._needsManuallyCompositing = true;
          break;
        }
      }
    }

    var prevLayer = null;
    var incrementalLayerCount = 0;
    var i = 0;

    for (; i &lt; list.length; i++) {
      var _el = list[i];
      var qlevel = _el.qlevel;
      var layer = void 0; // PENDING If change one incremental element style ?
      // TODO Where there are non-incremental elements between incremental elements.

      if (_el.incremental) {
        layer = this.getLayer(qlevel + INCREMENTAL_INC, this._needsManuallyCompositing);
        layer.incremental = true;
        incrementalLayerCount = 1;
      } else {
        layer = this.getLayer(qlevel + (incrementalLayerCount &gt; 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);
      }

      if (!layer.__builtin__) {
        console.log(&#39;ZLevel &#39; + qlevel + &#39; has been used by unkown layer &#39; + layer.id);
      }

      if (layer !== prevLayer) {
        layer.__used = true;

        if (layer.__startIndex !== i) {
          layer.__dirty = true;
        }

        layer.__startIndex = i;

        if (!layer.incremental) {
          layer.__drawIndex = i;
        } else {
          // Mark layer draw index needs to update.
          layer.__drawIndex = -1;
        }

        updatePrevLayer(i);
        prevLayer = layer;
      }

      if (_el.__dirty) {
        layer.__dirty = true;

        if (layer.incremental &amp;&amp; layer.__drawIndex &lt; 0) {
          // Start draw from the first dirty element.
          layer.__drawIndex = i;
        }
      }
    }

    updatePrevLayer(i);
    this.eachBuiltinLayer(function (layer, z) {
      // Used in last frame but not in this frame. Needs clear
      if (!layer.__used &amp;&amp; layer.getElementCount() &gt; 0) {
        layer.__dirty = true;
        layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0;
      } // For incremental layer. In case start index changed and no elements are dirty.


      if (layer.__dirty &amp;&amp; layer.__drawIndex &lt; 0) {
        layer.__drawIndex = layer.__startIndex;
      }
    });
  },

<span id='qrenderer-canvas-CanvasPainter-method-clear'>  /**
</span>   * @method clear
   * 清除hover层外所有内容
   */
  clear: function clear() {
    this.eachBuiltinLayer(this._clearLayer);
    return this;
  },

<span id='qrenderer-canvas-CanvasPainter-method-_clearLayer'>  /**
</span>   * @private
   * @method _clearLayer
   */
  _clearLayer: function _clearLayer(layer) {
    layer.clear();
  },

<span id='qrenderer-canvas-CanvasPainter-method-setBackgroundColor'>  /**
</span>   * @method setBackgroundColor
   */
  setBackgroundColor: function setBackgroundColor(backgroundColor) {
    this._backgroundColor = backgroundColor;
  },

<span id='qrenderer-canvas-CanvasPainter-method-configLayer'>  /**
</span>   * @method configLayer
   * 修改指定zlevel的绘制参数
   *
   * @param {String} qlevel
   * @param {Object} [config] 配置对象
   * @param {String} [config.clearColor=0] 每次清空画布的颜色
   * @param {String} [config.motionBlur=false] 是否开启动态模糊
   * @param {Number} [config.lastFrameAlpha=0.7] 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
   */
  configLayer: function configLayer(qlevel, config) {
    if (config) {
      var layerConfig = this._layerConfig;

      if (!layerConfig[qlevel]) {
        layerConfig[qlevel] = config;
      } else {
        dataUtil.merge(layerConfig[qlevel], config, true);
      }

      for (var i = 0; i &lt; this._qlevelList.length; i++) {
        var _zlevel = this._qlevelList[i];

        if (_zlevel === qlevel || _zlevel === qlevel + EL_AFTER_INCREMENTAL_INC) {
          var layer = this._layers[_zlevel];
          dataUtil.merge(layer, layerConfig[qlevel], true);
        }
      }
    }
  },

<span id='qrenderer-canvas-CanvasPainter-method-resize'>  /**
</span>   * @method resize
   * 区域大小变化后重绘
   * @param {Number} width
   * @param {Number} height
   */
  resize: function resize(width, height) {
    if (!this._domRoot.style) {
      // Maybe in node or worker
      if (width == null || height == null) {
        return;
      }

      this._width = width;
      this._height = height;
      this.getLayer(CANVAS_QLEVEL).resize(width, height);
    } else {
      var domRoot = this._domRoot; // FIXME Why ?

      domRoot.style.display = &#39;none&#39;; // Save input w/h

      var options = this._opts;
      width != null &amp;&amp; (options.width = width);
      height != null &amp;&amp; (options.height = height);
      width = this._getSize(0);
      height = this._getSize(1);
      domRoot.style.display = &#39;&#39;; // 优化没有实际改变的resize

      if (this._width !== width || height !== this._height) {
        domRoot.style.width = width + &#39;px&#39;;
        domRoot.style.height = height + &#39;px&#39;;

        for (var id in this._layers) {
          if (this._layers.hasOwnProperty(id)) {
            this._layers[id].resize(width, height);
          }
        }

        dataUtil.each(this._progressiveLayers, function (layer) {
          layer.resize(width, height);
        });
        this.refresh(true);
      }

      this._width = width;
      this._height = height;
    }

    return this;
  },

<span id='qrenderer-canvas-CanvasPainter-method-clearLayer'>  /**
</span>   * @method clearLayer
   * 清除单独的一个层
   * @param {Number} qlevel
   */
  clearLayer: function clearLayer(qlevel) {
    var layer = this._layers[qlevel];

    if (layer) {
      layer.clear();
    }
  },

<span id='qrenderer-canvas-CanvasPainter-method-dispose'>  /**
</span>   * @method dispose
   * 释放
   */
  dispose: function dispose() {
    this.root.innerHTML = &#39;&#39;;
    this.root = this.storage = this._domRoot = this._layers = null;
  },

<span id='qrenderer-canvas-CanvasPainter-method-getRenderedCanvas'>  /**
</span>   * @method getRenderedCanvas
   * Get canvas which has all thing rendered
   * @param {Object} [options]
   * @param {String} [options.backgroundColor]
   * @param {Number} [options.pixelRatio]
   */
  getRenderedCanvas: function getRenderedCanvas(options) {
    options = options || {};

    if (this._singleCanvas &amp;&amp; !this._compositeManually) {
      return this._layers[CANVAS_QLEVEL].dom;
    }

    var imageLayer = new CanvasLayer(&#39;image&#39;, this._width, this._height, options.pixelRatio || this.dpr);
    imageLayer.initContext();
    imageLayer.clear(false, options.backgroundColor || this._backgroundColor);

    if (options.pixelRatio &lt;= this.dpr) {
      this.refresh();
      var width = imageLayer.dom.width;
      var height = imageLayer.dom.height;
      var ctx = imageLayer.ctx;
      this.eachLayer(function (layer) {
        if (layer.__builtin__) {
          ctx.drawImage(layer.canvasInstance, 0, 0, width, height);
        } else if (layer.renderToCanvas) {
          imageLayer.ctx.save();
          layer.renderToCanvas(imageLayer.ctx);
          imageLayer.ctx.restore();
        }
      });
    } else {
      // PENDING, echarts-gl and incremental rendering.
      var scope = {};
      var displayList = this.storage.getDisplayList(true);

      for (var i = 0; i &lt; displayList.length; i++) {
        var el = displayList[i];

        this._doPaintEl(el, imageLayer, true, scope);
      }
    }

    return imageLayer.dom;
  },

<span id='qrenderer-canvas-CanvasPainter-method-getWidth'>  /**
</span>   * @method getWidth
   * 获取绘图区域宽度
   * @return {Number}
   */
  getWidth: function getWidth() {
    return this._width;
  },

<span id='qrenderer-canvas-CanvasPainter-method-getHeight'>  /**
</span>   * @method getHeight
   * 获取绘图区域高度
   * @return {Number}
   */
  getHeight: function getHeight() {
    return this._height;
  },

<span id='qrenderer-canvas-CanvasPainter-method-_getSize'>  /**
</span>   * @method _getSize
   * @param {*} whIdx 
   */
  _getSize: function _getSize(whIdx) {
    var options = this._opts;
    var wh = [&#39;width&#39;, &#39;height&#39;][whIdx];
    var cwh = [&#39;clientWidth&#39;, &#39;clientHeight&#39;][whIdx];
    var plt = [&#39;paddingLeft&#39;, &#39;paddingTop&#39;][whIdx];
    var prb = [&#39;paddingRight&#39;, &#39;paddingBottom&#39;][whIdx];

    if (options[wh] != null &amp;&amp; options[wh] !== &#39;auto&#39;) {
      return parseFloat(options[wh]);
    }

    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.

    var stl = document.defaultView.getComputedStyle(root);
    return (root[cwh] || dataUtil.parseInt10(stl[wh]) || dataUtil.parseInt10(root.style[wh])) - (dataUtil.parseInt10(stl[plt]) || 0) - (dataUtil.parseInt10(stl[prb]) || 0) | 0;
  },

<span id='qrenderer-canvas-CanvasPainter-method-pathToImage'>  /**
</span>   * @method pathToImage
   * @param {*} path 
   * @param {*} dpr 
   */
  pathToImage: function pathToImage(path, dpr) {
    dpr = dpr || this.dpr;
    var canvas = canvasUtil.createCanvas();
    var ctx = canvasUtil.getContext(canvas);
    var rect = path.getBoundingRect();
    var style = path.style;
    var shadowBlurSize = style.shadowBlur * dpr;
    var shadowOffsetX = style.shadowOffsetX * dpr;
    var shadowOffsetY = style.shadowOffsetY * dpr;
    var lineWidth = style.hasStroke() ? style.lineWidth : 0;
    var leftMargin = mathMax(lineWidth / 2, -shadowOffsetX + shadowBlurSize);
    var rightMargin = mathMax(lineWidth / 2, shadowOffsetX + shadowBlurSize);
    var topMargin = mathMax(lineWidth / 2, -shadowOffsetY + shadowBlurSize);
    var bottomMargin = mathMax(lineWidth / 2, shadowOffsetY + shadowBlurSize);
    var width = rect.width + leftMargin + rightMargin;
    var height = rect.height + topMargin + bottomMargin;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, width, height);
    ctx.dpr = dpr;
    var pathTransform = {
      position: path.position,
      rotation: path.rotation,
      scale: path.scale
    };
    path.position = [leftMargin - rect.x, topMargin - rect.y];
    path.rotation = 0;
    path.scale = [1, 1];
    path.updateTransform();

    if (path) {
      path.brush(ctx);
    }

    var ImageShape = Image;
    var imgShape = new ImageShape({
      style: {
        x: 0,
        y: 0,
        image: canvas
      }
    });

    if (pathTransform.position != null) {
      imgShape.position = path.position = pathTransform.position;
    }

    if (pathTransform.rotation != null) {
      imgShape.rotation = path.rotation = pathTransform.rotation;
    }

    if (pathTransform.scale != null) {
      imgShape.scale = path.scale = pathTransform.scale;
    }

    return imgShape;
  }
};
var _default = CanvasPainter;
module.exports = _default;</pre>
</body>
</html>
