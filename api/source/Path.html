<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">var Displayable = require(&quot;./Displayable&quot;);

var dataUtil = require(&quot;../core/utils/dataStructureUtil&quot;);

var PathProxy = require(&quot;../core/PathProxy&quot;);

var pathContain = require(&quot;../core/contain/path&quot;);

var Pattern = require(&quot;./Pattern&quot;);

<span id='zrender-graphic-Path'>/**
</span> * @class zrender.graphic.Path 
 * @docauthor 大漠穷秋 &lt;damoqiongqiu@126.com&gt;
 */
var getCanvasPattern = Pattern.prototype.getCanvasPattern;
var abs = Math.abs;
var pathProxyForDraw = new PathProxy(true);
<span id='zrender-graphic-Path-method-constructor'>/**
</span> * @method constructor Path
 * @param {Object} opts
 */

function Path(opts) {
  Displayable.call(this, opts);
<span id='zrender-graphic-Path-property-path'>  /**
</span>   * @property {PathProxy}
   * @readOnly
   */

  this.path = null;
}

Path.prototype = {
  constructor: Path,
  type: &#39;path&#39;,
  __dirtyPath: true,
  strokeContainThreshold: 5,
  // This item default to be false. But in map series in echarts,
  // in order to improve performance, it should be set to true,
  // so the shorty segment won&#39;t draw.
  segmentIgnoreThreshold: 0,

<span id='zrender-graphic-Path-property-subPixelOptimize'>  /**
</span>   * See `module:zrender/src/graphic/helper/subPixelOptimize`.
   * @property {Boolean}
   */
  subPixelOptimize: false,

<span id='zrender-graphic-Path-method-brush'>  /**
</span>   * @method brush
   * @param {Object} ctx 
   * @param {Element} prevEl 
   */
  brush: function brush(ctx, prevEl) {
    var style = this.style;
    var path = this.path || pathProxyForDraw;
    var hasStroke = style.hasStroke();
    var hasFill = style.hasFill();
    var fill = style.fill;
    var stroke = style.stroke;
    var hasFillGradient = hasFill &amp;&amp; !!fill.colorStops;
    var hasStrokeGradient = hasStroke &amp;&amp; !!stroke.colorStops;
    var hasFillPattern = hasFill &amp;&amp; !!fill.image;
    var hasStrokePattern = hasStroke &amp;&amp; !!stroke.image;
    style.bind(ctx, this, prevEl);
    this.setTransform(ctx);

    if (this.__dirty) {
      var rect; // Update gradient because bounding rect may changed

      if (hasFillGradient) {
        rect = rect || this.getBoundingRect();
        this._fillGradient = style.getGradient(ctx, fill, rect);
      }

      if (hasStrokeGradient) {
        rect = rect || this.getBoundingRect();
        this._strokeGradient = style.getGradient(ctx, stroke, rect);
      }
    } // Use the gradient or pattern


    if (hasFillGradient) {
      // PENDING If may have affect the state
      ctx.fillStyle = this._fillGradient;
    } else if (hasFillPattern) {
      ctx.fillStyle = getCanvasPattern.call(fill, ctx);
    }

    if (hasStrokeGradient) {
      ctx.strokeStyle = this._strokeGradient;
    } else if (hasStrokePattern) {
      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
    }

    var lineDash = style.lineDash;
    var lineDashOffset = style.lineDashOffset;
    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy

    var scale = this.getGlobalScale();
    path.setScale(scale[0], scale[1], this.segmentIgnoreThreshold); // Proxy context
    // Rebuild path in following 2 cases
    // 1. Path is dirty
    // 2. Path needs javascript implemented lineDash stroking.
    //    In this case, lineDash information will not be saved in PathProxy

    if (this.__dirtyPath || lineDash &amp;&amp; !ctxLineDash &amp;&amp; hasStroke) {
      path.beginPath(ctx); // Setting line dash before build path

      if (lineDash &amp;&amp; !ctxLineDash) {
        path.setLineDash(lineDash);
        path.setLineDashOffset(lineDashOffset);
      }

      this.buildPath(path, this.shape, false); // Clear path dirty flag

      if (this.path) {
        this.__dirtyPath = false;
      }
    } else {
      // Replay path building
      ctx.beginPath();
      this.path.rebuildPath(ctx);
    }

    if (hasFill) {
      if (style.fillOpacity != null) {
        var originalGlobalAlpha = ctx.globalAlpha;
        ctx.globalAlpha = style.fillOpacity * style.opacity;
        path.fill(ctx);
        ctx.globalAlpha = originalGlobalAlpha;
      } else {
        path.fill(ctx);
      }
    }

    if (lineDash &amp;&amp; ctxLineDash) {
      ctx.setLineDash(lineDash);
      ctx.lineDashOffset = lineDashOffset;
    }

    if (hasStroke) {
      if (style.strokeOpacity != null) {
        var _originalGlobalAlpha = ctx.globalAlpha;
        ctx.globalAlpha = style.strokeOpacity * style.opacity;
        path.stroke(ctx);
        ctx.globalAlpha = _originalGlobalAlpha;
      } else {
        path.stroke(ctx);
      }
    }

    if (lineDash &amp;&amp; ctxLineDash) {
      // PENDING
      // Remove lineDash
      ctx.setLineDash([]);
    } // Draw rect text


    if (style.text != null) {
      // Only restore transform when needs draw text.
      this.restoreTransform(ctx);
      this.drawRectText(ctx, this.getBoundingRect());
    }
  },

<span id='zrender-graphic-Path-method-buildPath'>  /**
</span>   * @method buildPath
   * When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
   * Like in circle
   * @param {*} ctx 
   * @param {*} shapeCfg 
   * @param {*} inBundle 
   */
  buildPath: function buildPath(ctx, shapeCfg, inBundle) {},

<span id='zrender-graphic-Path-method-createPathProxy'>  /**
</span>   * @method createPathProxy
   */
  createPathProxy: function createPathProxy() {
    this.path = new PathProxy();
  },

<span id='zrender-graphic-Path-method-getBoundingRect'>  /**
</span>   * @method getBoundingRect
   */
  getBoundingRect: function getBoundingRect() {
    var rect = this._rect;
    var style = this.style;
    var needsUpdateRect = !rect;

    if (needsUpdateRect) {
      var path = this.path;

      if (!path) {
        // Create path on demand.
        path = this.path = new PathProxy();
      }

      if (this.__dirtyPath) {
        path.beginPath();
        this.buildPath(path, this.shape, false);
      }

      rect = path.getBoundingRect();
    }

    this._rect = rect;

    if (style.hasStroke()) {
      // Needs update rect with stroke lineWidth when
      // 1. Element changes scale or lineWidth
      // 2. Shape is changed
      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());

      if (this.__dirty || needsUpdateRect) {
        rectWithStroke.copy(rect); // FIXME Must after updateTransform

        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical

        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill

        if (!style.hasFill()) {
          w = Math.max(w, this.strokeContainThreshold || 4);
        } // Consider line width
        // Line scale can&#39;t be 0;


        if (lineScale &gt; 1e-10) {
          rectWithStroke.width += w / lineScale;
          rectWithStroke.height += w / lineScale;
          rectWithStroke.x -= w / lineScale / 2;
          rectWithStroke.y -= w / lineScale / 2;
        }
      } // Return rect with stroke


      return rectWithStroke;
    }

    return rect;
  },

<span id='zrender-graphic-Path-method-contain'>  /**
</span>   * @method contain
   * @param {*} x 
   * @param {*} y 
   */
  contain: function contain(x, y) {
    var localPos = this.transformCoordToLocal(x, y);
    var rect = this.getBoundingRect();
    var style = this.style;
    x = localPos[0];
    y = localPos[1];

    if (rect.contain(x, y)) {
      var pathData = this.path.data;

      if (style.hasStroke()) {
        var lineWidth = style.lineWidth;
        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can&#39;t be 0;

        if (lineScale &gt; 1e-10) {
          // Only add extra hover lineWidth when there are no fill
          if (!style.hasFill()) {
            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
          }

          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {
            return true;
          }
        }
      }

      if (style.hasFill()) {
        return pathContain.contain(pathData, x, y);
      }
    }

    return false;
  },

<span id='zrender-graphic-Path-method-dirty'>  /**
</span>   * @method dirty
   * @param  {Boolean} dirtyPath
   */
  dirty: function dirty(dirtyPath) {
    if (dirtyPath == null) {
      dirtyPath = true;
    } // Only mark dirty, not mark clean


    if (dirtyPath) {
      this.__dirtyPath = dirtyPath;
      this._rect = null;
    }

    this.__dirty = this.__dirtyText = true;
    this.__zr &amp;&amp; this.__zr.refresh(); // Used as a clipping path

    if (this.__clipTarget) {
      this.__clipTarget.dirty();
    }
  },

<span id='zrender-graphic-Path-method-animateShape'>  /**
</span>   * @method animateShape
   * Alias for animate(&#39;shape&#39;)
   * @param {Boolean} loop
   */
  animateShape: function animateShape(loop) {
    return this.animate(&#39;shape&#39;, loop);
  },

<span id='zrender-graphic-Path-method-attrKV'>  /**
</span>   * @method attrKV
   * Overwrite attrKV
   * @param {*} key 
   * @param {Object} value 
   */
  attrKV: function attrKV(key, value) {
    // FIXME
    if (key === &#39;shape&#39;) {
      this.setShape(value);
      this.__dirtyPath = true;
      this._rect = null;
    } else {
      Displayable.prototype.attrKV.call(this, key, value);
    }
  },

<span id='zrender-graphic-Path-method-setShape'>  /**
</span>   * @method setShape
   * @param {Object|String} key
   * @param {Object} value
   */
  setShape: function setShape(key, value) {
    var shape = this.shape; // Path from string may not have shape

    if (shape) {
      if (dataUtil.isObject(key)) {
        for (var name in key) {
          if (key.hasOwnProperty(name)) {
            shape[name] = key[name];
          }
        }
      } else {
        shape[key] = value;
      }

      this.dirty(true);
    }

    return this;
  },

<span id='zrender-graphic-Path-method-getLineScale'>  /**
</span>   * @method getLineScale
   */
  getLineScale: function getLineScale() {
    var m = this.transform; // Get the line scale.
    // Determinant of `m` means how much the area is enlarged by the
    // transformation. So its square root can be used as a scale factor
    // for width.

    return m &amp;&amp; abs(m[0] - 1) &gt; 1e-10 &amp;&amp; abs(m[3] - 1) &gt; 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;
  }
};
<span id='zrender-graphic-Path-method-extend'>/**
</span> * 扩展一个 Path element, 比如星形，圆等。
 * Extend a path element
 * @param {Object} props
 * @param {string} props.type Path type
 * @param {Function} props.init Initialize
 * @param {Function} props.buildPath Overwrite buildPath method
 * @param {Object} [props.style] Extended default style config
 * @param {Object} [props.shape] Extended default shape config
 */

Path.extend = function (defaults) {
  var Sub = function Sub(opts) {
    Path.call(this, opts);

    if (defaults.style) {
      // Extend default style
      this.style.extendFrom(defaults.style, false);
    } // Extend default shape


    var defaultShape = defaults.shape;

    if (defaultShape) {
      this.shape = this.shape || {};
      var thisShape = this.shape;

      for (var name in defaultShape) {
        if (!thisShape.hasOwnProperty(name) &amp;&amp; defaultShape.hasOwnProperty(name)) {
          thisShape[name] = defaultShape[name];
        }
      }
    }

    defaults.init &amp;&amp; defaults.init.call(this, opts);
  };

  dataUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象

  for (var name in defaults) {
    // Extending prototype values and methods
    if (name !== &#39;style&#39; &amp;&amp; name !== &#39;shape&#39;) {
      Sub.prototype[name] = defaults[name];
    }
  }

  return Sub;
};

dataUtil.inherits(Path, Displayable);
var _default = Path;
module.exports = _default;</pre>
</body>
</html>
