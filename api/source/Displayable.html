<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">var classUtil = require(&quot;../core/utils/class_util&quot;);

var Style = require(&quot;./Style&quot;);

var Element = require(&quot;./Element&quot;);

var RectText = require(&quot;./RectText&quot;);

function _typeof(obj) { &quot;@babel/helpers - typeof&quot;; if (typeof Symbol === &quot;function&quot; &amp;&amp; typeof Symbol.iterator === &quot;symbol&quot;) { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj &amp;&amp; typeof Symbol === &quot;function&quot; &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? &quot;symbol&quot; : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(&quot;Cannot call a class as a function&quot;); } }

function _defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&quot;value&quot; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call &amp;&amp; (_typeof(call) === &quot;object&quot; || typeof call === &quot;function&quot;)) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(&quot;this hasn&#39;t been initialised - super() hasn&#39;t been called&quot;); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) { throw new TypeError(&quot;Super expression must either be null or a function&quot;); } subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

<span id='qrenderer-graphic-Displayable'>/**
</span> * @abstract
 * @class qrenderer.graphic.Displayable 
 * 
 * Base class of all displayable graphic objects.
 * 
 * 所有图形对象的基类，抽象类。
 * 
 * @docauthor 大漠穷秋 &lt;damoqiongqiu@126.com&gt;
 */
var Displayable =
/*#__PURE__*/
function (_Element) {
  _inherits(Displayable, _Element);

<span id='qrenderer-graphic-Displayable-method-constructor'>  /**
</span>   * @method constructor
   * @param {*} options 
   */
  function Displayable() {
    var _this;

    var options = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Displayable);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Displayable).call(this, options));
<span id='qrenderer-graphic-Displayable-property-__clipPaths'>    /**
</span>     * @private
     * @property  __clipPaths
     * Shapes for cascade clipping.
     * Can only be `null`/`undefined` or an non-empty array, MUST NOT be an empty array.
     * because it is easy to only using null to check whether clipPaths changed.
     */

    _this.__clipPaths = null; // FIXME Stateful must be mixined after style is setted
    // Stateful.call(this, options);

<span id='qrenderer-graphic-Displayable-method-calculateTextPosition'>    /**
</span>     * The String value of `textPosition` needs to be calculated to a real postion.
     * For example, `&#39;inside&#39;` is calculated to `[rect.width/2, rect.height/2]`
     * by default. See `contain/text.js#calculateTextPosition` for more details.
     * But some coutom shapes like &quot;pin&quot;, &quot;flag&quot; have center that is not exactly
     * `[width/2, height/2]`. So we provide this hook to customize the calculation
     * for those shapes. It will be called if the `style.textPosition` is a String.
     * @param {Obejct} [out] Prepared out object. If not provided, this method should
     *        be responsible for creating one.
     * @param {Style} style
     * @param {Object} rect {x, y, width, height}
     * @return {Obejct} out The same as the input out.
     *         {
     *             x: Number. mandatory.
     *             y: Number. mandatory.
     *             textAlign: String. optional. use style.textAlign by default.
     *             textVerticalAlign: String. optional. use style.textVerticalAlign by default.
     *         }
     */

    _this.calculateTextPosition = null;
<span id='qrenderer-graphic-Displayable-property-type'>    /**
</span>     * @property {String} type
     */

    _this.type = &#39;displayable&#39;;
<span id='qrenderer-graphic-Displayable-property-invisible'>    /**
</span>     * @property {Boolean} invisible
     * Whether the displayable object is visible. when it is true, the displayable object
     * is not drawn, but the mouse event can still trigger the object.
     */

    _this.invisible = false;
<span id='qrenderer-graphic-Displayable-property-z'>    /**
</span>     * @property {Number} z
     */

    _this.z = 0;
<span id='qrenderer-graphic-Displayable-property-z2'>    /**
</span>     * @property {Number} z2
     */

    _this.z2 = 0;
<span id='qrenderer-graphic-Displayable-property-qlevel'>    /**
</span>     * @property {Number} qlevel
     * The q level determines the displayable object can be drawn in which layer canvas.
     */

    _this.qlevel = 0;
<span id='qrenderer-graphic-Displayable-property-draggable'>    /**
</span>     * @property {Boolean} draggable
     * Whether it can be dragged.
     */

    _this.draggable = false;
<span id='qrenderer-graphic-Displayable-property-dragging'>    /**
</span>     * @property {Boolean} dragging
     * Whether is it dragging.
     */

    _this.dragging = false;
<span id='qrenderer-graphic-Displayable-property-silent'>    /**
</span>     * @property {Boolean} silent
     * Whether to respond to mouse events.
     */

    _this.silent = false;
<span id='qrenderer-graphic-Displayable-property-culling'>    /**
</span>     * @property {Boolean} culling
     * If enable culling
     */

    _this.culling = false;
<span id='qrenderer-graphic-Displayable-property-cursor'>    /**
</span>     * @property {String} cursor
     * Mouse cursor when hovered
     */

    _this.cursor = &#39;pointer&#39;;
<span id='qrenderer-graphic-Displayable-property-rectHover'>    /**
</span>     * @property {String} rectHover
     * If hover area is bounding rect
     */

    _this.rectHover = false;
<span id='qrenderer-graphic-Displayable-property-progressive'>    /**
</span>     * @property {Boolean} progressive
     * Render the element progressively when the value &gt;= 0,
     * usefull for large data.
     */

    _this.progressive = false;
<span id='qrenderer-graphic-Displayable-property-incremental'>    /**
</span>     * @property {Boolean} incremental
     */

    _this.incremental = false;
<span id='qrenderer-graphic-Displayable-property-globalScaleRatio'>    /**
</span>     * @property {Boolean} globalScaleRatio
     * Scale ratio for global scale.
     */

    _this.globalScaleRatio = 1;
<span id='qrenderer-graphic-Displayable-property-style'>    /**
</span>     * @property {Style} style
     */

    _this.style = new Style(options.style, _assertThisInitialized(_this));
<span id='qrenderer-graphic-Displayable-property-shape'>    /**
</span>     * @property {Object} shape 形状
     */

    _this.shape = {}; // Extend default shape

    var defaultShape = _this.options.shape;

    if (defaultShape) {
      for (var name in defaultShape) {
        if (!_this.shape.hasOwnProperty(name) &amp;&amp; defaultShape.hasOwnProperty(name)) {
          _this.shape[name] = defaultShape[name];
        }
      }
    } // FIXME 不能 extend position, rotation 等引用对象 TODO:why?


    classUtil.copyOwnProperties(_assertThisInitialized(_this), _this.options, [&#39;style&#39;, &#39;shape&#39;]);
    return _this;
  }
<span id='qrenderer-graphic-Displayable-method-beforeBrush'>  /**
</span>   * @protected
   * @method beforeBrush
   */


  _createClass(Displayable, [{
    key: &quot;beforeBrush&quot;,
    value: function beforeBrush(ctx) {}
<span id='qrenderer-graphic-Displayable-method-brush'>    /**
</span>     * @protected
     * @method brush
     * Callback during brush.
     */

  }, {
    key: &quot;brush&quot;,
    value: function brush(ctx, prevEl) {}
<span id='qrenderer-graphic-Displayable-method-afterBrush'>    /**
</span>     * @protected
     * @method afterBrush
     */

  }, {
    key: &quot;afterBrush&quot;,
    value: function afterBrush(ctx) {}
<span id='qrenderer-graphic-Displayable-method-getBoundingRect'>    /**
</span>     * @protected
     * @method getBoundingRect
     */

  }, {
    key: &quot;getBoundingRect&quot;,
    value: function getBoundingRect() {}
<span id='qrenderer-graphic-Displayable-method-contain'>    /**
</span>     * @protected
     * @method contain
     * 
     * If displayable element contain coord x, y, this is an util function for
     * determine where two elements overlap.
     * 
     * 图元是否包含坐标(x,y)，此工具方法用来判断两个图元是否重叠。
     * 
     * @param  {Number} x
     * @param  {Number} y
     * @return {Boolean}
     */

  }, {
    key: &quot;contain&quot;,
    value: function contain(x, y) {
      return this.rectContain(x, y);
    }
<span id='qrenderer-graphic-Displayable-method-rectContain'>    /**
</span>     * @protected
     * @method rectContain
     * 
     * If bounding rect of element contain coord x, y.
     * 
     * 用来判断当前图元的外框矩形是否包含坐标点(x,y)。
     * 
     * @param  {Number} x
     * @param  {Number} y
     * @return {Boolean}
     */

  }, {
    key: &quot;rectContain&quot;,
    value: function rectContain(x, y) {
      var coord = this.transformCoordToLocal(x, y);
      var rect = this.getBoundingRect();
      return rect.contain(coord[0], coord[1]);
    }
<span id='qrenderer-graphic-Displayable-method-traverse'>    /**
</span>     * @method traverse
     * @param  {Function} cb
     * @param  {Object}  context
     */

  }, {
    key: &quot;traverse&quot;,
    value: function traverse(cb, context) {
      cb.call(context, this);
    }
<span id='qrenderer-graphic-Displayable-method-animateStyle'>    /**
</span>     * @method animateStyle
     * Alias for animate(&#39;style&#39;)
     * @param {Boolean} loop
     */

  }, {
    key: &quot;animateStyle&quot;,
    value: function animateStyle(loop) {
      return this.animate(&#39;style&#39;, loop);
    }
<span id='qrenderer-graphic-Displayable-method-attrKV'>    /**
</span>     * @method attrKV
     * @param {*} key 
     * @param {*} value 
     */

  }, {
    key: &quot;attrKV&quot;,
    value: function attrKV(key, value) {
      if (key !== &#39;style&#39;) {
        Element.prototype.attrKV.call(this, key, value);
      } else {
        this.style.set(value);
      }
    }
<span id='qrenderer-graphic-Displayable-method-setStyle'>    /**
</span>     * @method setStyle
     * @param {Object|String} key
     * @param {*} value
     */

  }, {
    key: &quot;setStyle&quot;,
    value: function setStyle(key, value) {
      this.style.set(key, value);
      this.dirty(false);
      return this;
    }
<span id='qrenderer-graphic-Displayable-method-useStyle'>    /**
</span>     * @method useStyle
     * Use given style object
     * @param  {Object} obj
     */

  }, {
    key: &quot;useStyle&quot;,
    value: function useStyle(obj) {
      this.style = new Style(obj, this);
      this.dirty(false);
      return this;
    }
  }]);

  return Displayable;
}(Element);

classUtil.mixin(Displayable, RectText);
var _default = Displayable;
module.exports = _default;</pre>
</body>
</html>
